# **Протоколы и маршрутизация**
## **1. Структура HTTP пакета**
**HTTP-пакет** состоит из 3-х основных частей: 
- **Request Line(Линия запросов)**: Определяет тип запроса. Включает в себя:
	- **Метод запроса**: Например, `GET`, `POST`, `PUT`, `DELETE`
	- **URL**: Идентифицирует запрашиваемый ресурс
	- **Версия HTTP-протокола**: Используемая версия, например `HTTP/1.1`
- **Headers(Заголовки)**: Содержат метаинформацию о запросе, например, тип содержимого (`Content-Type`), хост (`Host`), авторизационные данные и т.д.
- **Body(Тело запроса)**: Непосредственно передаваемые данные, например, содержимое формы или JSON-объект. Оно отделяется от заголовков пустой строкой и является опциональным

## **2. Протокол REST**
### **Методы:** 
GET, POST, PUT, DELETE
### **Параметры:** 
URL путь(`/users/123`), query string parameters(`?page=2`), request body(`{"title": "1984", "author": "George Orwell"}`), headers(`Authorization: Bearer <token>`)
### **Код ответов HTTP сервера**: 

|Группа|Назначение|Основные коды|
|---|---|---|
|**1xx**|Информационные|100 Continue, 101 Switching Protocols|
|**2xx**|**Успех**|**200 OK** (успешный GET, PUT, PATCH)  <br>**201 Created** (успешный POST)  <br>**204 No Content** (успешный DELETE, нет тела ответа)|
|**3xx**|Перенаправление|301 Moved Permanently, 304 Not Modified|
|**4xx**|**Ошибка клиента**|**400 Bad Request** (неверный синтаксис запроса)  <br>**401 Unauthorized** (требуется аутентификация)  <br>**403 Forbidden** (нет прав доступа)  <br>**404 Not Found** (ресурс не найден)  <br>**409 Conflict** (конфликт, напр., попытка создать дубль)  <br>**422 Unprocessable Entity** (семиантическая ошибка в данных)|
|**5xx**|**Ошибка сервера**|**500 Internal Server Error** (общая ошибка сервера)  <br>**502 Bad Gateway**  <br>**503 Service Unavailable** (сервис временно недоступен)|
### **Результаты выполнения запроса**:
1. **Статус-код**.
2. **Заголовки (Headers):** Например, `Content-Type: application/json`.
3. **Тело ответа (Response Body):**
    - Для **GET** — запрошенные данные (список или объект).
    - Для **POST** — обычно созданный объект (часто с добавленным серверным ID).
    - Для **PUT** — обновленный объект.
    - Для **DELETE** — чаще всего пустое тело (204 No Content) или статус удаления.
    - При **ошибке (4xx, 5xx)** — тело с описанием ошибки (обычно в JSON).

### **Форматы JSON, Base64 и др.**
1. **JSON (JavaScript Object Notation)**
   ```json
    {
      "id": 123,
      "title": "Преступление и наказание",
      "authors": ["Ф. М. Достоевский"],
      "inStock": true
    } 
   ```
2. **Base64**
   Схема кодирования бинарных данных в текстовую строку. Используется для передачи файлов(изображений, PDF) внутри JSON или других текстовых форматов.
	```json 
    {
      "avatar": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA..."
    }
	```
3. **Другие форматы:**
    - **XML:** Более старый, но все еще используемый формат (особенно в корпоративных системах). Более многословный, чем JSON.
    - **Form Data (`application/x-www-form-urlencoded` или `multipart/form-data`):** Используется, когда данные приходят из HTML-форм. Последний — для загрузки файлов.
    - **YAML, MessagePack, Protocol Buffers (protobuf):** Альтернативные форматы, которые могут использоваться для повышения эффективности или удобства в специфичных сценариях.


## **3. Балансировка / распределение нагрузки**

**Балансировщик (proxy)**: Nginx принимает запросы и распределяет их между бэкенд-серверами (upstream).
 - **Upstream-группы**: Группировка серверов(например, бэкенда).
   ```nginx
      upstream backend {
        server backend1.example.com;
        server backend2.example.com;
      }
        location / {
        proxy_pass http://backend;
      }
   ```
 - **Маршрутизация по location/эндпоинтам**: Разные пути направляются в разные upstream-группы.
   ```nginx
      location /api/ {
        proxy_pass http://api_backend;
      }
      location /static/ {
          proxy_pass http://static_backend;
      }
   ```
 - **Условная маршрутизация (if)**: Используется осторожно (может нарушать обработку). Обычно для проверки заголовков, cookie.
   ```nginx
      if ($http_custom_header = "special") {
        proxy_pass http://special_backend;
      }  
   ```
 - **Таблицы сопоставления (map)**: Более эффективная замена `if` для сложных условий. Создает переменную на основе значения другой.
   ```nginx
      map $http_user_agent $backend {
        default        main_backend;
        "~*mobile"     mobile_backend;
      }
   ```
 - **Способы распределения (upstream)**:
	 - `round-robin` (по умолчанию) – циклический перебор.
    
	- `weight` – с учетом веса сервера.
    
	- `least_conn` – наименьшее число соединений.
    
	- `ip_hash` – постоянство сессии (клиент → один сервер).
    
	- `hash` – произвольный ключ (например, `$arg_user_id`).
 - **Коды ответов**:
	 - `proxy_next_upstream` – указать, при каких ошибках (timeout, 5xx) пробовать другой сервер.
    
	- Возвращать свои страницы ошибок или редиректы.



# **Мониторинг и профилирование работы приложения**
## **4. Использование метрик для мониторинга работы приложения**
### **Классификация метрик**
1. Технические метрики (Infrastructure/System):
   Ресурсы: CPU, память, диск, сеть
   Контейнеры/поды: кол-во, статусы, рестарты
2. Эксплуатационные метрики (Application/Operational):
   Производительность: latency, throughput, RPS
   Ошибки: коды ответов HTTP
   Доступность: uptime, health checks
   Базы данных: query time, connections
3. Бизнес-метрики (Business):
   Транзакции: успешные/неуспешные платежи
   Выручка или пользователи

### **Типы метрик Prometheus**:
- **Counter** (счётчики: запросы, ошибки)
- **Gauge** (текущее значение: память, температура)
- **Histogram** (распределение: время ответа)
- **Summary** (сводка, предрасчитанные квантили)

### **Процессы сбора и агрегации**
1. **Сбор:**
    - **Pull-модель:** Prometheus тянет метрики с /metrics
        
2. **Агрегация:**
    - **Recording rules** в Prometheus (предрасчет)
    - **PromQL агрегации:** `sum()`, `rate()`, `avg_over_time()`
    - **Уровни детализации:** raw → 5m → 1h (downsampling)
        
3. **Хранение:**
    - Prometheus TSDB (локальное)
        
#### **Prometheus-стек**
**Компоненты:**
- **Prometheus Server:** сбор, хранение, запросы
- **Alertmanager:** управление алертами
- **Grafana:** визуализация

## **5. Использование системы логирования для сбора и анализа информации о работе приложения**
**Процесс записи логов:**  
Приложение использует библиотеки (logrus, zap) для записи событий с указанием уровня:
- **DEBUG** — отладочная информация (включается при разработке)
- **INFO** — штатная работа приложения (старт, основные операции)
- **WARN** — неожиданные, но некритические ситуации
- **ERROR** — ошибки, требующие внимания
- **FATAL** — критические сбои, после которых приложение останавливается


Логи пишутся в **stdout/stderr** или файлы в структурированном формате (например, JSON).
### **Сбор и отправка логов**

**Promtail** — агент для сбора логов в стеке **Grafana Loki**:
1. Обнаруживает новые лог-файлы
2. Парсит записи, извлекает метки (labels): `job`, `pod`, `environment`
3. Отправляет сжатые логи в **Loki** для хранения
    
### **Хранение и обработка в Loki**
- **Индексирует только метки**, а не полный текст — экономит ресурсы
- Лог-строки хранятся сжатыми в объектном хранилище
- Поддерживает политики хранения (retention)
- Запросы через **LogQL** (аналогично PromQL)
    
### **Анализ логов**
В **Grafana** с подключенным Loki:
- Поиск по меткам: `{job="api"} |= "timeout"`
- Фильтрация по уровню: `{level="ERROR"}`
- Агрегация: подсчёт ошибок за период
- **Корреляция логов и метрик** — одновременный просмотр ошибок и падения RPS/рост latency
    
**Пример LogQL:**  
`{app="auth"} | json | rate(5m)` — анализ структурированных логов с вычислением частоты событий.


# **Системы виртуализации для запуска и управления приложениями**
## **6. Docker и виртуализация в контейнерах**
**Docker** — платформа для контейнеризации приложений. Позволяет упаковывать приложение со всеми зависимостями в стандартизированный блок — **контейнер**.
- **Контейнер** — изолированная среда для запуска приложения, содержащая код, зависимости, настройки.
    
- **Образ (image)** — шаблон для создания контейнера (как «класс» в ООП). Собирается из Dockerfile и хранится в реестре (Docker Hub, private registry).
    
### **Разница: виртуализация vs контейнеризация**

|**Виртуализация**|**Контейнеризация**|
|---|---|
|Запускает полную гостевую ОС|Использует ядро хостовой ОС|
|Высокое потребление ресурсов|Лёгкая, быстрый запуск|
|Полная изоляция|Изоляция на уровне процессов|
|Подходит для изоляции ОС, тестов железа|Подходит для приложений, микросервисов|

**Контейнеры** не требуют отдельной ОС, используют ресурсы хоста напрямую → быстрее, легче, удобнее для CI/CD.

### **Dockerfile и сборка приложений**

**Dockerfile** — инструкция для сборки образа:
```dockerfile
FROM node:18
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY src/ ./src/
CMD ["node", "src/index.js"]
```

- **FROM** — базовый образ
- **RUN** — выполнить команду при сборке
- **COPY/ADD** — добавить файлы
- **CMD/ENTRYPOINT** — команда запуска контейнера
    

Сборка:  
`docker build -t myapp:1.0 .`
### **Передача параметров через переменные окружения**
**Способы задания переменных:**
1. **В Dockerfile (не для секретов):**
    ```dockerfile
    ENV APP_PORT=8080
    ```
2. **При запуске контейнера:**
    ```bash
    docker run -e "DB_HOST=db" myapp
    ```
    
1. **Через файл `.env`:**
	```bash
	docker run --env-file .env myapp
	```
    

**Использование в приложении:**  
Приложение читает переменные через `process.env` (Node.js), `os.getenv` (Python) и т.д.

## **7. Kubernetes - система управления контейнерами**
**Kubernetes** — система оркестрации контейнеров для автоматизированного управления приложениями. Позволяет:
- Масштабировать приложения
- Обеспечивать отказоустойчивость
- Управлять обновлениями (rolling updates)
- Распределять нагрузку между серверами
    

Используется в продакшене для управления сотнями/тысячами контейнеров.
### **Stateless vs Stateful приложения**

|**Stateless (без состояния)**|**Stateful (с состоянием)**|
|---|---|
|Не хранят данные между запросами|Хранят состояние (сессии, данные)|
|Каждый запрос независим|Запросы зависят от предыдущих|
|Легко масштабируются|Сложнее масштабировать|
|Пример: API, фронтенд|Пример: БД (PostgreSQL), кэш (Redis)|

**Stateless** — стандарт для микросервисов.  
**Stateful** — требуют постоянного хранилища и осторожного управления.

### **Основные компоненты K8s**

1. **Control Plane (мастер-ноды):**
    - **kube-apiserver** — входная точка для управления (REST API)
    - **etcd** — распределённая БД (хранит состояние кластера)
    - **kube-scheduler** — распределяет поды по нодам
    - **kube-controller-manager** — следит за состоянием (реплики, ноды)
        
2. **Worker Nodes (рабочие ноды):**
    - **Kubelet** — агент на ноде, управляет контейнерами
    - **kube-proxy** — сетевой прокси, балансировка
    - **Container Runtime** (Docker, containerd) — запускает контейнеры
        

### **Основные сущности (объекты) K8s**

1. **Namespace** — виртуальный кластер внутри K8s для изоляции ресурсов (dev, staging, prod).
2. **Pod** — минимальная единица развёртывания. Содержит 1+ контейнеров, общие сеть/хранилище.
3. **Deployment** — декларативное управление приложениями. Запускает и обновляет поды через ReplicaSet.
4. **ReplicaSet** — поддерживает заданное количество идентичных подов (реплик).
5. **DaemonSet** — гарантирует запуск пода на каждой (или выбранной) ноде (например, для логирования, мониторинга).
6. **ConfigMap** — хранит конфигурации (несекретные данные) для пода.
7. **Secret** — хранит конфиденциальные данные (пароли, токены) в закодированном виде.
8. **Service** — абстракция для доступа к группе подов (стабильный DNS/IP). Типы:
    - ClusterIP (внутренний)
    - NodePort (доступ снаружи по порту ноды)
    - LoadBalancer (облачный балансировщик)
9. **Ingress** — управляет внешним HTTP(S)-трафиком (роутинг по доменам, TLS). Работает с Ingress-контроллером (nginx, traefik).
    

**Пример связи:**  
Deployment → создаёт ReplicaSet → управляет подами → Service обеспечивает доступ → Ingress направляет трафик извне.

**Простой манифест:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: app
        image: myapp:1.0
        ports:
        - containerPort: 8080
```